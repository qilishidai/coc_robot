# 任务开发进阶

> 本教程面向已经掌握基础任务开发的开发者，介绍OCR、YOLO等高级检测功能的使用。

## 🎯 适合人群

- ✅ 已完成 [开发第一个任务](./02-开发第一个任务.md) 教程
- ✅ 熟悉基础任务框架
- ✅ 需要使用图像识别功能

## 📚 本教程内容

1. OCR文字识别
2. YOLO目标检测
3. 模板匹配进阶
4. 复杂任务流程设计
5. 性能优化技巧
6. 调试方法

---

## 1️⃣ OCR文字识别

### 什么是OCR？

OCR（Optical Character Recognition）= 光学字符识别，能从图像中识别文字。

**适用场景**：
- 识别资源数量（金币、圣水、黑油）
- 识别建筑名称
- 识别英雄等级
- 识别任务文本

### 基础用法

```python
from 任务流程.基础任务框架 import 基础任务

class 识别资源(基础任务):
    def 执行(self) -> bool:
        try:
            上下文 = self.上下文

            # 1. 截取资源区域
            资源区域 = 上下文.op.获取屏幕图像cv(100, 50, 300, 100)
            #                                    ↑    ↑   ↑    ↑
            #                                   左上x 左上y 右下x 右下y

            # 2. OCR识别
            结果, _ = self.ocr引擎(资源区域)

            # 3. 解析结果
            for 行 in 结果:
                坐标 = 行[0]  # [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
                文本 = 行[1]  # (识别的文字, 置信度)

                上下文.置脚本状态(f"识别到: {文本[0]}, 置信度: {文本[1]}")

            return True

        except Exception as e:
            self.异常处理(e)
            return False
```

### 提取数字

```python
import re

def 提取数字(self, 图像):
    """从图像中提取数字"""
    结果, _ = self.ocr引擎(图像)

    for 行 in 结果:
        文本 = 行[1][0]

        # 使用正则提取数字
        匹配 = re.findall(r'\d+', 文本)
        if 匹配:
            数字 = int(''.join(匹配))
            return 数字

    return None
```

**使用示例**：

```python
class 检查金币(基础任务):
    def 执行(self) -> bool:
        try:
            上下文 = self.上下文

            # 截取金币显示区域
            金币区域 = 上下文.op.获取屏幕图像cv(50, 20, 150, 50)

            # 提取数字
            金币数量 = self.提取数字(金币区域)

            if 金币数量 is not None:
                上下文.置脚本状态(f"当前金币: {金币数量}")

                # 判断是否需要刷墙
                if 金币数量 > 5000000:
                    上下文.置脚本状态("金币充足，准备刷墙")
                    # ... 执行刷墙逻辑

            return True

        except Exception as e:
            self.异常处理(e)
            return False
```

### OCR优化技巧

**1. 图像预处理**

```python
import cv2

def 预处理图像(self, 图像):
    """提高OCR准确率"""
    # 转灰度
    灰度图 = cv2.cvtColor(图像, cv2.COLOR_BGR2GRAY)

    # 二值化
    _, 二值图 = cv2.threshold(灰度图, 127, 255, cv2.THRESH_BINARY)

    # 去噪
    去噪图 = cv2.medianBlur(二值图, 3)

    return 去噪图
```

**2. 识别特定区域**

```python
# ✅ 正确：只截取需要的区域
金币图像 = 上下文.op.获取屏幕图像cv(50, 20, 150, 50)

# ❌ 错误：截取整个屏幕再裁剪
全屏 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
金币图像 = 全屏[20:50, 50:150]  # 浪费性能
```

**3. 多次尝试**

```python
def 稳定识别数字(self, 区域坐标, 最大尝试=3):
    """多次识别取平均值，提高准确性"""
    结果列表 = []

    for i in range(最大尝试):
        图像 = self.上下文.op.获取屏幕图像cv(*区域坐标)
        数字 = self.提取数字(图像)
        if 数字 is not None:
            结果列表.append(数字)
        self.上下文.脚本延时(100)

    if 结果列表:
        # 返回中位数
        结果列表.sort()
        return 结果列表[len(结果列表) // 2]

    return None
```

---

## 2️⃣ YOLO目标检测

### 什么是YOLO？

YOLO（You Only Look Once）= 实时目标检测算法，能识别图像中的物体位置和类别。

**适用场景**：
- 检测建筑位置
- 检测兵种位置
- 检测资源建筑
- 检测特定目标（如天鹰火炮）

### ⚠️ 重要提示：自带模型的能力范围

**项目自带的YOLO模型只能检测以下4种目标**：
- ✅ 金矿
- ✅ 金库
- ✅ 圣水采集器
- ✅ 圣水瓶

**以下目标需要自己训练模型才能检测**：
- ❌ 天鹰火炮
- ❌ 大本营
- ❌ 城墙
- ❌ 兵种
- ❌ 其他任何建筑

**💡 提示**：如果你想**训练自己的YOLO模型**，请查看 [YOLO检测器完整指南](./06-YOLO检测器完整指南.md)，包含数据集收集、标注、训练到部署的完整流程。

### 基础用法

```python
class 检测建筑(基础任务):
    def 执行(self) -> bool:
        try:
            上下文 = self.上下文

            # 1. 截取游戏画面
            屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

            # 2. YOLO检测
            检测结果 = self.检测器.检测(屏幕图像)

            # 3. 遍历检测结果
            for 目标 in 检测结果:
                类别 = 目标["类别名称"]
                坐标 = 目标["裁剪坐标"]  # (x1, y1, x2, y2)
                置信度 = 目标["置信度"]

                上下文.置脚本状态(
                    f"检测到: {类别}, "
                    f"位置: ({坐标[0]}, {坐标[1]}), "
                    f"置信度: {置信度:.2f}"
                )

                # 计算中心点
                中心x = (坐标[0] + 坐标[2]) // 2
                中心y = (坐标[1] + 坐标[3]) // 2

                # 点击目标
                上下文.点击(中心x, 中心y, 500)

            return True

        except Exception as e:
            self.异常处理(e)
            return False
```

### 过滤检测结果

**按类别过滤**：

```python
def 查找特定建筑(self, 建筑名称):
    """查找特定类别的建筑"""
    屏幕图像 = self.上下文.op.获取屏幕图像cv(0, 0, 800, 600)
    检测结果 = self.检测器.检测(屏幕图像)

    目标列表 = []
    for 目标 in 检测结果:
        if 目标["类别名称"] == 建筑名称:
            目标列表.append(目标)

    return 目标列表
```

**按置信度过滤**：

```python
def 高置信度检测(self, 最小置信度=0.8):
    """只返回高置信度的检测结果"""
    屏幕图像 = self.上下文.op.获取屏幕图像cv(0, 0, 800, 600)
    检测结果 = self.检测器.检测(屏幕图像)

    高置信度结果 = []
    for 目标 in 检测结果:
        if 目标["置信度"] >= 最小置信度:
            高置信度结果.append(目标)

    return 高置信度结果
```

**按大小过滤**：

```python
def 过滤小目标(self, 检测结果, 最小宽度=20, 最小高度=20):
    """过滤掉太小的目标"""
    结果列表 = []

    for 目标 in 检测结果:
        x1, y1, x2, y2 = 目标["裁剪坐标"]
        宽度 = x2 - x1
        高度 = y2 - y1

        if 宽度 >= 最小宽度 and 高度 >= 最小高度:
            结果列表.append(目标)

    return 结果列表
```

### 实战案例：检测天鹰火炮

> ⚠️ **注意**：此示例需要**自己训练包含"天鹰火炮"类别的模型**。项目自带模型不支持天鹰火炮检测。
> 请先参考 [YOLO检测器完整指南](./06-YOLO检测器完整指南.md) 训练模型。

```python
class 检测天鹰火炮(基础任务):
    def 执行(self) -> bool:
        try:
            上下文 = self.上下文

            # 1. 获取屏幕图像
            屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

            # 2. YOLO检测
            检测结果 = self.检测器.检测(屏幕图像)

            # 3. 查找天鹰火炮
            天鹰列表 = []
            for 目标 in 检测结果:
                if 目标["类别名称"] == "天鹰火炮":
                    # 过滤小目标
                    x1, y1, x2, y2 = 目标["裁剪坐标"]
                    宽度 = x2 - x1
                    高度 = y2 - y1

                    if 宽度 >= 20 and 高度 >= 20:
                        天鹰列表.append(目标)

            if 天鹰列表:
                上下文.置脚本状态(f"检测到 {len(天鹰列表)} 个天鹰火炮")

                # 攻击第一个天鹰火炮
                目标 = 天鹰列表[0]
                坐标 = 目标["裁剪坐标"]
                中心x = (坐标[0] + 坐标[2]) // 2
                中心y = (坐标[1] + 坐标[3]) // 2

                # 使用法术攻击11次
                for i in range(11):
                    # 添加随机偏移，模拟人类
                    import random
                    偏移x = random.randint(-5, 5)
                    偏移y = random.randint(-5, 5)

                    上下文.点击(中心x + 偏移x, 中心y + 偏移y, 300)
                    上下文.置脚本状态(f"第 {i+1}/11 次攻击")
            else:
                上下文.置脚本状态("未检测到天鹰火炮")

            return True

        except Exception as e:
            self.异常处理(e)
            return False
```

---

## 3️⃣ 模板匹配进阶

### 多模板匹配

```python
# 同时匹配多个模板，返回第一个匹配的
是否匹配, (x, y), _ = self.模板识别.执行匹配(
    图像,
    "按钮1.bmp|按钮2.bmp|按钮3.bmp",
    0.9
)
```

### 调整阈值

```python
# 降低阈值，提高匹配率（但可能误匹配）
是否匹配, _, _ = self.模板识别.执行匹配(图像, "模糊按钮.bmp", 0.7)

# 提高阈值，减少误匹配（但可能漏检）
是否匹配, _, _ = self.模板识别.执行匹配(图像, "清晰按钮.bmp", 0.95)
```

### 区域匹配

```python
# 只在特定区域查找模板（参数：左上x, 左上y, 右下x, 右下y）
按钮区域 = 上下文.op.获取屏幕图像cv(600, 500, 800, 600)
是否匹配, (x, y), _ = self.模板识别.执行匹配(按钮区域, "确认.bmp", 0.9)

if 是否匹配:
    # 注意：坐标是相对于按钮区域的，需要加上偏移
    实际x = 600 + x
    实际y = 500 + y
    上下文.点击(实际x, 实际y, 500)
```

### 循环查找模板

```python
def 等待模板出现(self, 模板名称, 超时秒数=10):
    """循环查找模板，直到出现或超时"""
    开始时间 = time.time()

    while time.time() - 开始时间 < 超时秒数:
        屏幕图像 = self.上下文.op.获取屏幕图像cv(0, 0, 800, 600)
        是否匹配, (x, y), _ = self.模板识别.执行匹配(
            屏幕图像, 模板名称, 0.9
        )

        if 是否匹配:
            return True, (x, y)

        self.上下文.脚本延时(500)

    return False, (0, 0)
```

---

## 4️⃣ 复杂任务流程设计

### 任务链模式

```python
class 复杂任务(基础任务):
    def 执行(self) -> bool:
        try:
            上下文 = self.上下文

            # 步骤1：准备
            if not self.准备阶段():
                return False

            # 步骤2：执行
            if not self.执行阶段():
                return False

            # 步骤3：清理
            if not self.清理阶段():
                return False

            return True

        except Exception as e:
            self.异常处理(e)
            return False

    def 准备阶段(self) -> bool:
        self.上下文.置脚本状态("准备阶段...")
        # ... 准备逻辑
        return True

    def 执行阶段(self) -> bool:
        self.上下文.置脚本状态("执行阶段...")
        # ... 执行逻辑
        return True

    def 清理阶段(self) -> bool:
        self.上下文.置脚本状态("清理阶段...")
        # ... 清理逻辑
        return True
```

### 状态机模式

```python
from enum import Enum

class 任务状态(Enum):
    初始化 = 1
    搜索目标 = 2
    执行操作 = 3
    等待结果 = 4
    完成 = 5

class 状态机任务(基础任务):
    def __init__(self, 上下文):
        super().__init__(上下文)
        self.当前状态 = 任务状态.初始化

    def 执行(self) -> bool:
        try:
            while self.当前状态 != 任务状态.完成:
                if self.当前状态 == 任务状态.初始化:
                    self.处理初始化()
                elif self.当前状态 == 任务状态.搜索目标:
                    self.处理搜索()
                elif self.当前状态 == 任务状态.执行操作:
                    self.处理操作()
                elif self.当前状态 == 任务状态.等待结果:
                    self.处理等待()

            return True

        except Exception as e:
            self.异常处理(e)
            return False

    def 处理初始化(self):
        self.上下文.置脚本状态("初始化...")
        # ... 初始化逻辑
        self.当前状态 = 任务状态.搜索目标

    def 处理搜索(self):
        self.上下文.置脚本状态("搜索目标...")
        # ... 搜索逻辑
        self.当前状态 = 任务状态.执行操作

    # ... 其他状态处理
```

### 重试机制

```python
def 带重试的操作(self, 操作函数, 最大重试=3):
    """操作失败时自动重试"""
    for 尝试次数 in range(最大重试):
        try:
            self.上下文.置脚本状态(f"尝试 {尝试次数 + 1}/{最大重试}")

            结果 = 操作函数()
            if 结果:
                return True

            self.上下文.脚本延时(1000)

        except Exception as e:
            self.上下文.置脚本状态(f"操作失败: {e}")
            if 尝试次数 == 最大重试 - 1:
                raise

    return False
```

---

## 5️⃣ 性能优化技巧

### 1. 减少截图次数

```python
# ❌ 错误：多次截取同一区域
for i in range(10):
    图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
    # 处理图像

# ✅ 正确：复用截图
图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
for i in range(10):
    # 处理图像
```

### 2. 只截取需要的区域

```python
# ❌ 错误：截取全屏再裁剪
全屏 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
区域 = 全屏[100:200, 100:300]

# ✅ 正确：直接截取目标区域（参数：左上x, 左上y, 右下x, 右下y）
区域 = 上下文.op.获取屏幕图像cv(100, 100, 300, 200)
```

### 3. 适当的延时

```python
# 操作后等待界面响应
上下文.点击(x, y, 500)  # 点击后延时500ms

# 等待动画完成
上下文.脚本延时(1000)  # 等待1秒
```

### 4. 提前返回

```python
# ✅ 正确：检测到目标立即返回
def 查找按钮(self):
    for i in range(10):
        屏幕图像 = self.上下文.op.获取屏幕图像cv(0, 0, 800, 600)
        是否匹配, (x, y), _ = self.模板识别.执行匹配(屏幕图像, "按钮.bmp", 0.9)

        if 是否匹配:
            return True, (x, y)  # 立即返回

        self.上下文.脚本延时(500)

    return False, (0, 0)
```

---

## 6️⃣ 调试方法

### 保存调试图像

```python
import cv2
import time

def 保存调试图像(self, 图像, 前缀="debug"):
    """保存图像用于调试"""
    文件名 = f"{前缀}_{int(time.time())}.png"
    cv2.imwrite(文件名, 图像)
    self.上下文.置脚本状态(f"已保存调试图像: {文件名}")
```

### 绘制检测框

```python
import cv2

def 绘制YOLO结果(self, 图像, 检测结果):
    """在图像上绘制检测框"""
    调试图像 = 图像.copy()

    for 目标 in 检测结果:
        x1, y1, x2, y2 = 目标["裁剪坐标"]
        类别 = 目标["类别名称"]
        置信度 = 目标["置信度"]

        # 绘制矩形
        cv2.rectangle(调试图像, (x1, y1), (x2, y2), (0, 255, 0), 2)

        # 绘制文本
        标签 = f"{类别} {置信度:.2f}"
        cv2.putText(调试图像, 标签, (x1, y1-10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

    self.保存调试图像(调试图像, "yolo_result")
    return 调试图像
```

### 打印详细日志

```python
def 执行(self) -> bool:
    try:
        上下文 = self.上下文

        # 记录开始时间
        开始时间 = time.time()
        上下文.置脚本状态("任务开始")

        # ... 任务逻辑

        # 记录耗时
        耗时 = time.time() - 开始时间
        上下文.置脚本状态(f"任务完成，耗时: {耗时:.2f}秒")

        return True

    except Exception as e:
        self.异常处理(e)
        return False
```

### 单步调试

```python
# 在关键位置暂停
import pdb
pdb.set_trace()  # 程序会在这里暂停，可以检查变量
```

---

## 🎯 完整实战案例

### 案例：自动收集资源

```python
from 任务流程.基础任务框架 import 基础任务
import time

class 自动收集资源(基础任务):
    """自动点击资源建筑收集资源"""

    def 执行(self) -> bool:
        try:
            上下文 = self.上下文
            上下文.置脚本状态("开始收集资源")

            # 1. 检测资源建筑
            资源建筑列表 = self.检测资源建筑()

            if not 资源建筑列表:
                上下文.置脚本状态("未检测到可收集的资源建筑")
                return True

            上下文.置脚本状态(f"检测到 {len(资源建筑列表)} 个资源建筑")

            # 2. 逐个点击收集
            收集数量 = 0
            for 建筑 in 资源建筑列表:
                if self.收集单个建筑(建筑):
                    收集数量 += 1

            上下文.置脚本状态(f"收集完成，共收集 {收集数量} 个建筑")
            return True

        except Exception as e:
            self.异常处理(e)
            return False

    def 检测资源建筑(self):
        """使用YOLO检测资源建筑"""
        上下文 = self.上下文

        # 截取游戏画面
        屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)

        # YOLO检测
        检测结果 = self.检测器.检测(屏幕图像)

        # 过滤资源建筑（注意：自带模型只支持这4种）
        资源建筑类型 = ["金矿", "圣水采集器"]  # 自带模型支持的采集类建筑
        资源建筑列表 = []

        for 目标 in 检测结果:
            if 目标["类别名称"] in 资源建筑类型:
                # 过滤置信度低的
                if 目标["置信度"] >= 0.7:
                    资源建筑列表.append(目标)

        return 资源建筑列表

    def 收集单个建筑(self, 建筑):
        """点击建筑收集资源"""
        上下文 = self.上下文

        # 计算建筑中心点
        坐标 = 建筑["裁剪坐标"]
        中心x = (坐标[0] + 坐标[2]) // 2
        中心y = (坐标[1] + 坐标[3]) // 2

        # 点击建筑
        上下文.点击(中心x, 中心y, 500)

        # 等待收集动画
        上下文.脚本延时(800)

        # 检测是否出现收集按钮
        屏幕图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
        是否匹配, (按钮x, 按钮y), _ = self.模板识别.执行匹配(
            屏幕图像, "收集按钮.bmp", 0.9
        )

        if 是否匹配:
            # 点击收集按钮
            上下文.点击(按钮x, 按钮y, 500)
            上下文.置脚本状态(f"收集 {建筑['类别名称']}")
            return True

        return False
```

---

## 💡 最佳实践

### ✅ 推荐做法

1. **使用预初始化的检测器**
   ```python
   # ✅ 使用 self.检测器
   结果 = self.检测器.检测(图像)
   ```

2. **合理的超时和重试**
   ```python
   # ✅ 设置最大循环次数
   最大尝试 = 50
   for i in range(最大尝试):
       # ...
       if i >= 最大尝试 - 1:
           raise RuntimeError("超过最大尝试次数")
   ```

3. **详细的日志**
   ```python
   # ✅ 记录关键步骤
   上下文.置脚本状态(f"正在处理第 {i+1}/{总数} 个目标")
   ```

### ❌ 避免的做法

1. **不要每次创建新检测器**
   ```python
   # ❌ 浪费资源
   检测器 = 线程安全YOLO检测器()
   ```

2. **不要无限循环**
   ```python
   # ❌ 可能死循环
   while True:
       # ...
   ```

3. **不要忽略异常**
   ```python
   # ❌ 吞掉异常
   try:
       # ...
   except:
       pass
   ```

---

## 🐛 常见问题

### 问题1：OCR识别不准

**解决**：
- 图像预处理（灰度化、二值化）
- 只截取文字区域
- 多次识别取平均值

### 问题2：YOLO检测不到目标

**解决**：
- **首先确认目标是否在自带模型支持范围内**（只支持：金矿、金库、圣水采集器、圣水瓶）
- 如果需要检测其他目标，必须[训练自己的模型](./06-YOLO检测器完整指南.md)
- 降低置信度阈值
- 确保图像质量足够好

### 问题3：模板匹配失败

**解决**：
- 检查分辨率和缩放比例
- 调整匹配阈值
- 使用多个模板

---

## 📚 进一步学习

- [添加配置选项](./04-添加配置选项.md) - 为任务添加可配置项
- [提交贡献](./05-提交贡献.md) - 提交你的代码
- [任务开发API](../核心文档/任务开发API.md) - 完整API参考

---

**下一步**：学习 [添加配置选项](./04-添加配置选项.md)，让用户可以自定义任务行为！
