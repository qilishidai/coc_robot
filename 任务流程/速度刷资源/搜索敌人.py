import time

from 任务流程.基础任务框架 import 任务上下文, 基础任务
from 任务流程.速度刷资源.进攻坐标逻辑计算 import 坐标, 判断目标点到可进攻边缘距离是否小于设定值
from 工具包.工具函数 import 打印运行耗时
from 模块.检测.OCR识别器 import 安全OCR引擎
from 模块.检测.YOLO检测器 import 线程安全YOLO检测器
from 模块.检测.模板匹配器 import 模板匹配引擎
import os
import cv2
import numpy as np
from datetime import datetime


class 搜索目标敌人任务(基础任务):
    """必须在找鱼的界面调用,也就是界面包含了敌人的村庄以及下一个按钮.自动搜索并评估敌人资源,和资源建筑位置，符合条件时返回"""
    def __init__(self, 上下文: '任务上下文'):
        super().__init__(上下文)
        self.ocr引擎 = 安全OCR引擎()
        self.检测器 = 线程安全YOLO检测器()
        self.模板识别 = 模板匹配引擎()

    def 执行(self, 上下文: 任务上下文) -> bool:
        try:
            搜索次数 = 1
            最小资源 = 上下文.数据库.获取机器人设置(上下文.机器人标志).欲进攻的最小资源
            原始目标 = 最小资源

            while True:

                if  self.执行单次搜索(上下文, 搜索次数, 最小资源):
                    return True
                # 每10次降低目标
                if 搜索次数 % 10 == 0:
                    最小资源 = self.调整搜索目标(上下文, 原始目标, 搜索次数)

                搜索次数 += 1
                上下文.脚本延时(500)

        except Exception as e:
            self.异常处理(上下文, e)
            return False

    def 执行单次搜索(self, 上下文: 任务上下文, 搜索次数: int, 最小资源: int) -> bool:
        """执行单次搜索流程，返回是否找到合适目标"""
        if not self.等待下一个按钮出现(上下文):
            raise RuntimeError("未找到下一个按钮，可能已在战斗界面")

        资源数据 = self.识别当前资源(上下文)
        self.打印状态信息(上下文, 搜索次数, 资源数据)

        if 资源数据["总资源"] >= 最小资源:
            靠近比例 = 上下文.数据库.获取机器人设置(上下文.机器人标志).欲进攻资源建筑靠近地图边缘最小比例

            if self.是否有足够资源建筑靠近边缘(上下文, 80, 最少靠近比例=靠近比例):
                # self.保存合格截图(上下文, 资源数据)
                return True
            else:
                上下文.置脚本状态("资源目标符合,但是不符合建筑靠近边缘目标,继续寻找,如果一直提示这个,请在设置页面设置(进攻资源边缘靠近比例下限)")
    

        self.点击下一个按钮(上下文)
        return False
    def 保存合格截图(self, 上下文: 任务上下文, 资源数据: dict):
        try:
            # 1. 获取截图
            截图 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
            if 截图 is None:
                return
                
            # 2. 使用绝对简单的路径（直接桌面）
            时间戳 = datetime.now().strftime("%Y%m%d_%H%M%S")
            文件名 = f"coc_target_{时间戳}_g{资源数据['金币']//1000}k_s{资源数据['圣水']//1000}k_d{资源数据['黑油']}.jpg"
            
            # 方案A: 直接保存到桌面
            桌面路径 = os.path.join(os.path.expanduser("~"), "Desktop", 文件名)
            
            print(f"尝试保存到桌面: {桌面路径}")
            
            # 方案B: 如果桌面保存失败，尝试程序所在目录
            成功 = cv2.imwrite(桌面路径, 截图)
            
            if 成功:
                if os.path.exists(桌面路径):
                    文件大小 = os.path.getsize(桌面路径)
                    print(f"✅ 保存成功! 文件大小: {文件大小} 字节")
                    上下文.置脚本状态(f"✅ 截图已保存到桌面: {文件名}")
                    return
                else:
                    print("⚠ 文件保存返回成功但不存在")
            
            # 方案B: 尝试程序目录
            程序目录 = os.path.dirname(os.path.abspath(__file__))
            程序路径 = os.path.join(程序目录, 文件名)
            
            print(f"尝试保存到程序目录: {程序路径}")
            成功 = cv2.imwrite(程序路径, 截图)
            
            if 成功 and os.path.exists(程序路径):
                print(f"✅ 程序目录保存成功!")
                上下文.置脚本状态(f"✅ 截图已保存: {文件名}")
            else:
                print(f"❌ 所有保存尝试都失败")
                上下文.置脚本状态("截图保存失败，请检查权限")
            
        except Exception as e:
            print(f"保存异常: {e}")
    def 打印状态信息(self, 上下文: 任务上下文, 搜索次数: int, 资源数据: dict):
        """更新状态信息"""
        状态信息 = (
            f"搜索次数[{搜索次数}] "
            f"金币[{资源数据['金币']}] "
            f"圣水[{资源数据['圣水']}] "
            f"黑油[{资源数据['黑油']}]"
        )
        上下文.置脚本状态(状态信息)

    def 是否有足够资源建筑靠近边缘(self,上下文,
            距离阈值: float,
            最少靠近数量: int = None,
            最少靠近比例: float = None,
            允许检测的类别: list = None,
            截图区域: tuple = (0, 0, 800, 600)
    ) -> bool:
        """
        判断是否存在足够数量（或比例）的金矿/圣水采集器靠近地图边缘。

        参数:
            距离阈值: float - 距离边缘小于此值时，视为“靠近边缘”
            最少靠近数量: int - 至少多少个靠近边缘（与比例二选一）
            最少靠近比例: float - 至少多少比例的目标靠近边缘（与数量二选一）
            允许检测的类别: list[str] - 默认为 ['金矿', '圣水采集器']
            截图区域: tuple - 截图区域 (x, y, 宽, 高)

        返回:
            bool - 是否达到靠近边缘的数量或比例条件
        """
        #YOLO检测器 = 线程安全YOLO检测器()
        if 允许检测的类别 is None:
            允许检测的类别 = ['金矿', '圣水采集器']

        if 最少靠近数量 is None and 最少靠近比例 is None:
            最少靠近数量 = 1  # 默认最少要一个目标靠近边缘

        左上x, 左上y, 宽, 高 = 截图区域
        全屏图像 = 上下文.op.获取屏幕图像cv(左上x, 左上y, 宽, 高)

        检测结果列表 = self.检测器.检测(全屏图像)

        总资源目标数量 = 0
        靠近边缘数量 = 0

        for 目标 in 检测结果列表:
            类别 = 目标['类别名称']
            if 类别 not in 允许检测的类别:
                continue

            总资源目标数量 += 1
            左, 上, 右, 下 = 目标['裁剪坐标']
            中心坐标 = 坐标((左 + 右) // 2, (上 + 下) // 2)

            if 判断目标点到可进攻边缘距离是否小于设定值(中心坐标, 距离阈值):
                靠近边缘数量 += 1
        if 总资源目标数量 == 0:
            上下文.置脚本状态(
                "未识别到资源建筑靠近边缘")
            return False  # 没有可判断的目标

        if 最少靠近比例 is not None:
            实际比例 = 靠近边缘数量 / 总资源目标数量
            return 实际比例 >= 最少靠近比例

        # 否则按数量判断
        return 靠近边缘数量 >= 最少靠近数量

    def 等待下一个按钮出现(self, 上下文) -> bool:
        """使用模板匹配检测下一个按钮"""

        按钮区域 = (0, 0, 800, 600)
        模板路径 = "下一个.bmp"
        超时时间 = 30  # 秒
        开始时间 = time.time()

        while time.time() - 开始时间 < 超时时间:
            # 获取按钮区域图像
            屏幕图像 = 上下文.op.获取屏幕图像cv(*按钮区域)

            # 执行模板匹配
            是否匹配, (x, y) ,_ = self.模板识别.执行匹配(屏幕图像,模板路径,相似度阈值=0.9)
            if 是否匹配:
                return True

            # 间隔检测
            上下文.脚本延时(500)

        # 超时处理
        上下文.置脚本状态("等待下一个按钮超时,已经卡白云30秒了", 超时的时间=10)
        return False

    @打印运行耗时
    def 识别当前资源(self, 上下文) -> dict:
        """修复后的资源识别方法"""
        try:


            全屏图像 = 上下文.op.获取屏幕图像cv(14,67,151,146)


            # 单次OCR识别（结果按顺序对应各区域）
            result, _ = self.ocr引擎(全屏图像)
            # 解析结果（假设OCR按行返回）
            金币文本 = str(result[0][1]) if len(result) > 0 else "0"
            圣水文本 = str(result[1][1]) if len(result) > 1 else "0"
            黑油文本 = str(result[2][1]) if len(result) > 2 else "0"



            return {
                "金币": self.文本转数值(金币文本),
                "圣水": self.文本转数值(圣水文本),
                "黑油": self.文本转数值(黑油文本),
                "总资源": self.文本转数值(金币文本) + self.文本转数值(圣水文本)
            }
        except Exception as e:
            上下文.置脚本状态(f"资源识别失败: {str(e)}")
            return {"金币": 0, "圣水": 0, "黑油": 0, "总资源": 0}

    def 文本转数值(self, 文本: str) -> int:
        """增强型文本转换"""
        try:
            # 处理常见OCR错误字符
            清理文本 = 文本.replace('O', '0').replace('o', '0').replace(' ', '')
            return int(''.join(filter(str.isdigit, 清理文本)))
        except:
            return 0  # 确保始终返回数值

    def 调整搜索目标(self, 上下文, 原始目标: int, 当前次数: int) -> int:
        """每10次降低搜索标准"""
        新目标 = max(原始目标 - int(原始目标 * 0.1), 100000)  # 最低不低于10万
        上下文.置脚本状态(
            f"搜索达{当前次数}次，降低目标至{新目标}",
            超时的时间=10
        )
        return 新目标

    def 点击下一个按钮(self, 上下文):
        """点击下一个按钮"""
        上下文.点击(694, 461)


    def 异常处理(self, 上下文: 任务上下文, 异常: Exception):
        super().异常处理(上下文, 异常)
        上下文.发送重启请求(f"搜索任务异常：{str(异常)}")